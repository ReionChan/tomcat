@startuml

header "@ReionChan"
footer "@ReionChan"

box "<font size=25>Tomcat 8.5 Http11NioProtocol 协议处理顺序图" #gold
participant Connector as Con
participant Http11NioProtocol as HNP
participant AbstractHttp11Protocol as AHP
participant AbstractProtocol as AP
participant CoyoteAdapter as CA
participant NioEndpoint as NE
participant ConnectionHandler as CH
participant ServerSocketChannel as SSC
participant ServerSocket as SS
participant NioSelectorPool as NSP
participant NioBlockingSelector as NBS
participant BlockPoller as BP
participant Poller as Po
participant Acceptor as Acc
participant SocketChannel as SC
participant NioChannel as NC
participant SocketBufferHandler as SBH
participant NioSocketWrapper as NSW
participant PollerEvent as PE
participant SocketProcessor as SP
participant Http11Processor as HP
participant AbstractProcessorLight as APL
end box

group#gold 服务端连接启动流程
    autonumber 1.1
    Con -> Con: Connector(Http11NioProtocol)
    activate Con
    Con -> HNP: newInstance()
    HNP -> NE: new
    AHP -> CH: new
    AHP -> NE: setHandler() 赋值 handler
    NE -> HNP: 赋值 endpoint
    HNP -> Con: 赋值 protocolHandler
    deactivate Con
    ||30||

    autonumber 2.1
    Con -> Con: initInternal()
    activate Con
    Con -> CA: new
    Con -> HNP: setAdapter(adapter)
    Con -> HNP: init()
    activate HNP
    HNP -> AHP: init()
    AHP -> AP: init()
    AP -> NE: init()
    activate NE
    NE -> NE: bindOnInit=false\n延迟执行 bind()
    deactivate NE
    NE -> HNP
    HNP -> Con
    deactivate HNP
    deactivate Con
    ||30||

    autonumber 3.1
    Con -> Con: startInternal()
    activate Con
    Con -> HNP: start()
    activate HNP
    HNP -> AP: start()
    AP -> NE: start()
    NE -> NE: 启动后才执行 bind()
    activate NE
    NE -> SSC: ServerSocketChannel.open()
    SSC -> SS: bind()
    NE -> NSP: selectorPool.open()
    activate NSP
    NSP -> NBS: new
    NBS -> BP: new & open()
    BP -> BP: run()
    note right
        1. 从事件队列获取 Runnable，并执行 run()
        2. 在 NIO 中以阻塞的形式读取请求体
    end note
    activate BP
    BP -> NSP
    NSP -> NE
    deactivate NSP
    deactivate NE
    NE -> NE: startInternal()
    activate NE
    NE -> NE: createExecutor() \n创建 Worker 线程池
    NE -> Po: 创建多个 Poller 线程
    Po -> Po: selector=Selector.open()
    Po -> Po: run()
    note right
        1. 从事件队列获取 PollerEvent 事件，并执行事件的 run()
           从而将 SocketChannel 从此类 selector 中注册或剔除
        2. 轮询此类 selector 中的 SelectionKey 进行读写处理
    end note
    activate Po
    NE -> Acc: 创建多个 Acceptor 线程
    Acc -> Acc: new
    NE -> Acc: start()
    NE -> HNP
    deactivate NE
    HNP -> Con
    deactivate Con
    deactivate HNP
    Acc -> Acc: run()
    note right
        接受客户端 SocketChannel 将其封装为 NioChannel 后
        注册到 NioEndpoint.Poller 的 PollerEvent 事件队列
    end note
    activate Acc
    ||30||
end

group#gold 处理客户端请求流程
    autonumber 4.1
    Acc -> SSC: accept()
    SSC -> SC: 获得 SocketChannel
    Acc -> Acc: setSocketOptions(sc)
    activate Acc
    Acc -> SBH: new
    Acc -> NC: 将 sc、handler 封装为 NioChannel
    Acc -> Po: register(channel)
    deactivate Acc
    activate Po
    Po -> NSW: new KA
    Po -> Po: PollerEvent 封装并添加到队列
    deactivate Po
    Po -> PE: 从队列取出并执行 run()
    activate PE
    PE -> PE: run()
    note right
        1. 如果为注册操作时，将 SC 注册到关联的 Po 的 Selector
        2. 否则将 SC 关联的 Selector 的 SK 设置本次事件的感兴趣的操作
        3. 或者清理 SC 关联的 Selector 的 SK
    end note
    deactivate PE
    Po -> Po: processKey()
    Po -> NE: processSocket()
    NE -> SP: createSocketProcessor()
    NE -> NE: 将 SocketProcessor\n交给 Worker 执行器执行
    ||30||

    autonumber 5.1
    SP -> CH: process()
    CH -> HP: 没有缓存对象就创建 Http11Processor
    note right
    1. 获得协议对象 Http11NioProtocol
    2. 调用它的 createProcessor()
    end note
    CH -> CH: 存入缓存对象方便下次获取\nMap<NioChannel, Http11Processor>
    CH -> APL: 调用 Http11Processor 父类 process()
    APL -> HP: service()
    HP -> CA: service(req, resp)
    CA -> Con: invoke(req, resp)
    note right
    由此 Connector 将请求交给容器 Engine
    进行各子容器的 Valve 链式调用
    由 StandardWrapperValve 传递给过滤器链 ApplicationFilterChain
    过滤器链最终交由 Servlet 的 service() 方法处理
    end note
end

@enduml